#if !defined( IMPLICITBINARYTREE_INL_INCLUDED )
#define IMPLICITBINARYTREE_INL_INCLUDED

#pragma once

/** @file *//********************************************************************************************************

                                                ImplicitBinaryTree.inl

						                    Copyright 2003, John J. Bolton
	--------------------------------------------------------------------------------------------------------------

	$Header: //depot/Roam/RoamTree/ImplicitBinaryTree.inl#3 $

	$NoKeywords: $

 ********************************************************************************************************************/

#include "ImplicitBinaryTree.h"

#include <memory>
#include <cassert>


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree< N >::ImplicitBinaryTree( int depth )
{
	assert( depth > 0 );

	m_Size = ( 1 << depth ) - OFFSET;

	m_paData = new N[ m_Size ];
	if ( !m_paData ) throw std::bad_alloc();
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree::ImplicitBinaryTree( std::auto_ptr< N > paData, size_t size )
	: m_paData( paData.release() ),
	m_Size( size )
{
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree::~ImplicitBinaryTree()
{
	delete[] m_paData;
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
N & ImplicitBinaryTree< N >::operator []( NodeRef i )
{
	assert_limits( 0, i - OFFSET, m_Size-1 );

	return m_paData[ i - OFFSET ];	// To avoid wasting space, data is shifted left
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
N const & ImplicitBinaryTree< N >::operator []( NodeRef i ) const
{
	assert_limits( 0, i - OFFSET, m_Size-1 );

	return m_paData[ i - OFFSET ];	// To avoid wasting space, data is shifted left
}


/********************************************************************************************************************/
/*																													*/
/*									NodeRef									*/
/*																													*/
/********************************************************************************************************************/


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree< N >::NodeRef::NodeRef( size_t i )
	: m_I( i )
{
	assert( i != INVALID );
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree< N >::NodeRef ImplicitBinaryTree< N >::NodeRef::Left() const
{
	return ( m_I << 1 ) + 0;
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree< N >::NodeRef ImplicitBinaryTree< N >::NodeRef::Right() const
{
	return ( m_I << 1 ) + 1;
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree< N >::NodeRef ImplicitBinaryTree< N >::NodeRef::Parent() const
{
	assert( m_I != ROOT );

	return m_I >> 1;
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
ImplicitBinaryTree< N >::NodeRef::operator size_t() const
{
	return m_I;
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
bool ImplicitBinaryTree< N >::NodeRef::IsLeft() const
{
	return ( ( m_I & 1 ) == 0 );
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
bool ImplicitBinaryTree< N >::NodeRef::IsRight() const
{
	return !IsLeft();
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
bool ImplicitBinaryTree< N >::NodeRef::IsRoot() const
{
	return ( m_I == ROOT );
}


/********************************************************************************************************************/
/*																													*/
/*																													*/
/********************************************************************************************************************/

template < class N >
int ImplicitBinaryTree< N >::NodeRef::Depth() const
{
	int		depth	= 0;
	size_t	i		= m_I;

	do
	{
		i >>= 1;
		++depth;
	} while ( i != 0 );
}


#endif // !defined( IMPLICITBINARYTREE_INL_INCLUDED )
